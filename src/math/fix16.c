#include "fix16.h"
#include "int64.h"
#ifdef MATH_FIX16

/* Subtraction and addition with overflow detection.
 * The versions without overflow detection are inlined in the header.
 */
#ifndef FIXMATH_NO_OVERFLOW
fix16_t fix16_add(fix16_t a, fix16_t b)
{
	// Use unsigned integers because overflow with signed integers is
	// an undefined operation (http://www.airs.com/blog/archives/120).
	uint32_t _a = a, _b = b;
	uint32_t sum = _a + _b;

	// Overflow can only happen if sign of a == sign of b, and then
	// it causes sign of sum != sign of a.
	if (!((_a ^ _b) & 0x80000000) && ((_a ^ sum) & 0x80000000))
		return fix16_overflow;
	
	return sum;
}

fix16_t fix16_sub(fix16_t a, fix16_t b)
{
	uint32_t _a = a, _b = b;
	uint32_t diff = _a - _b;

	// Overflow can only happen if sign of a != sign of b, and then
	// it causes sign of diff != sign of a.
	if (((_a ^ _b) & 0x80000000) && ((_a ^ diff) & 0x80000000))
		return fix16_overflow;
	
	return diff;
}

/* Saturating arithmetic */
fix16_t fix16_sadd(fix16_t a, fix16_t b)
{
	fix16_t result = fix16_add(a, b);

	if (result == fix16_overflow)
		return (a >= 0) ? fix16_maximum : fix16_minimum;

	return result;
}	

fix16_t fix16_ssub(fix16_t a, fix16_t b)
{
	fix16_t result = fix16_sub(a, b);

	if (result == fix16_overflow)
		return (a >= 0) ? fix16_maximum : fix16_minimum;

	return result;
}
#endif



/* 64-bit implementation for fix16_mul. Fastest version for e.g. ARM Cortex M3.
 * Performs a 32*32 -> 64bit multiplication. The middle 32 bits are the result,
 * bottom 16 bits are used for rounding, and upper 16 bits are used for overflow
 * detection.
 */
 
#if !defined(FIXMATH_NO_64BIT) && !defined(FIXMATH_OPTIMIZE_8BIT)
fix16_t fix16_mul(fix16_t inArg0, fix16_t inArg1)
{
	int64_t product = (int64_t)inArg0 * inArg1;
	
	#ifndef FIXMATH_NO_OVERFLOW
	// The upper 17 bits should all be the same (the sign).
	uint32_t upper = (product >> 47);
	#endif
	
	if (product < 0)
	{
		#ifndef FIXMATH_NO_OVERFLOW
		if (~upper)
				return fix16_overflow;
		#endif
		
		#ifndef FIXMATH_NO_ROUNDING
		// This adjustment is required in order to round -1/2 correctly
		product--;
		#endif
	}
	else
	{
		#ifndef FIXMATH_NO_OVERFLOW
		if (upper)
				return fix16_overflow;
		#endif
	}
	
	#ifdef FIXMATH_NO_ROUNDING
	return product >> 16;
	#else
	fix16_t result = product >> 16;
	result += (product & 0x8000) >> 15;
	
	return result;
	#endif
}
#endif

/* 32-bit implementation of fix16_mul. Potentially fast on 16-bit processors,
 * and this is a relatively good compromise for compilers that do not support
 * uint64_t. Uses 16*16->32bit multiplications.
 */
#if defined(FIXMATH_NO_64BIT) && !defined(FIXMATH_OPTIMIZE_8BIT)
fix16_t fix16_mul(fix16_t inArg0, fix16_t inArg1)
{
	// Each argument is divided to 16-bit parts.
	//					AB
	//			*	 CD
	// -----------
	//					BD	16 * 16 -> 32 bit products
	//				 CB
	//				 AD
	//				AC
	//			 |----| 64 bit product
	int32_t A = (inArg0 >> 16), C = (inArg1 >> 16);
	uint32_t B = (inArg0 & 0xFFFF), D = (inArg1 & 0xFFFF);
	
	int32_t AC = A*C;
	int32_t AD_CB = A*D + C*B;
	uint32_t BD = B*D;
	
	int32_t product_hi = AC + (AD_CB >> 16);
	
	// Handle carry from lower 32 bits to upper part of result.
	uint32_t ad_cb_temp = AD_CB << 16;
	uint32_t product_lo = BD + ad_cb_temp;
	if (product_lo < BD)
		product_hi++;
	
#ifndef FIXMATH_NO_OVERFLOW
	// The upper 17 bits should all be the same (the sign).
	if (product_hi >> 31 != product_hi >> 15)
		return fix16_overflow;
#endif
	
#ifdef FIXMATH_NO_ROUNDING
	return (product_hi << 16) | (product_lo >> 16);
#else
	// Subtracting 0x8000 (= 0.5) and then using signed right shift
	// achieves proper rounding to result-1, except in the corner
	// case of negative numbers and lowest word = 0x8000.
	// To handle that, we also have to subtract 1 for negative numbers.
	uint32_t product_lo_tmp = product_lo;
	product_lo -= 0x8000;
	product_lo -= (uint32_t)product_hi >> 31;
	if (product_lo > product_lo_tmp)
		product_hi--;
	
	// Discard the lowest 16 bits. Note that this is not exactly the same
	// as dividing by 0x10000. For example if product = -1, result will
	// also be -1 and not 0. This is compensated by adding +1 to the result
	// and compensating this in turn in the rounding above.
	fix16_t result = (product_hi << 16) | (product_lo >> 16);
	result += 1;
	return result;
#endif
}
#endif

/* 8-bit implementation of fix16_mul. Fastest on e.g. Atmel AVR.
 * Uses 8*8->16bit multiplications, and also skips any bytes that
 * are zero.
 */
#if defined(FIXMATH_OPTIMIZE_8BIT)
fix16_t fix16_mul(fix16_t inArg0, fix16_t inArg1)
{
	uint32_t _a = (inArg0 >= 0) ? inArg0 : (-inArg0);
	uint32_t _b = (inArg1 >= 0) ? inArg1 : (-inArg1);
	
	uint8_t va[4] = {_a, (_a >> 8), (_a >> 16), (_a >> 24)};
	uint8_t vb[4] = {_b, (_b >> 8), (_b >> 16), (_b >> 24)};
	
	uint32_t low = 0;
	uint32_t mid = 0;
	
	// Result column i depends on va[0..i] and vb[i..0]

	#ifndef FIXMATH_NO_OVERFLOW
	// i = 6
	if (va[3] && vb[3]) return fix16_overflow;
	#endif
	
	// i = 5
	if (va[2] && vb[3]) mid += (uint16_t)va[2] * vb[3];
	if (va[3] && vb[2]) mid += (uint16_t)va[3] * vb[2];
	mid <<= 8;
	
	// i = 4
	if (va[1] && vb[3]) mid += (uint16_t)va[1] * vb[3];
	if (va[2] && vb[2]) mid += (uint16_t)va[2] * vb[2];
	if (va[3] && vb[1]) mid += (uint16_t)va[3] * vb[1];
	
	#ifndef FIXMATH_NO_OVERFLOW
	if (mid & 0xFF000000) return fix16_overflow;
	#endif
	mid <<= 8;
	
	// i = 3
	if (va[0] && vb[3]) mid += (uint16_t)va[0] * vb[3];
	if (va[1] && vb[2]) mid += (uint16_t)va[1] * vb[2];
	if (va[2] && vb[1]) mid += (uint16_t)va[2] * vb[1];
	if (va[3] && vb[0]) mid += (uint16_t)va[3] * vb[0];
	
	#ifndef FIXMATH_NO_OVERFLOW
	if (mid & 0xFF000000) return fix16_overflow;
	#endif
	mid <<= 8;
	
	// i = 2
	if (va[0] && vb[2]) mid += (uint16_t)va[0] * vb[2];
	if (va[1] && vb[1]) mid += (uint16_t)va[1] * vb[1];
	if (va[2] && vb[0]) mid += (uint16_t)va[2] * vb[0];		
	
	// i = 1
	if (va[0] && vb[1]) low += (uint16_t)va[0] * vb[1];
	if (va[1] && vb[0]) low += (uint16_t)va[1] * vb[0];
	low <<= 8;
	
	// i = 0
	if (va[0] && vb[0]) low += (uint16_t)va[0] * vb[0];
	
	#ifndef FIXMATH_NO_ROUNDING
	low += 0x8000;
	#endif
	mid += (low >> 16);
	
	#ifndef FIXMATH_NO_OVERFLOW
	if (mid & 0x80000000)
		return fix16_overflow;
	#endif
	
	fix16_t result = mid;
	
	/* Figure out the sign of result */
	if ((inArg0 >= 0) != (inArg1 >= 0))
	{
		result = -result;
	}
	
	return result;
}
#endif

#ifndef FIXMATH_NO_OVERFLOW
/* Wrapper around fix16_mul to add saturating arithmetic. */
fix16_t fix16_smul(fix16_t inArg0, fix16_t inArg1)
{
	fix16_t result = fix16_mul(inArg0, inArg1);
	
	if (result == fix16_overflow)
	{
		if ((inArg0 >= 0) == (inArg1 >= 0))
			return fix16_maximum;
		else
			return fix16_minimum;
	}
	
	return result;
}
#endif

/* 32-bit implementation of fix16_div. Fastest version for e.g. ARM Cortex M3.
 * Performs 32-bit divisions repeatedly to reduce the remainder. For this to
 * be efficient, the processor has to have 32-bit hardware division.
 */
#if !defined(FIXMATH_OPTIMIZE_8BIT)
#ifdef __GNUC__
// Count leading zeros, using processor-specific instruction if available.
#define clz(x) (__builtin_clzl(x) - (8 * sizeof(long) - 32))
#else
static uint8_t clz(uint32_t x)
{
	uint8_t result = 0;
	if (x == 0) return 32;
	while (!(x & 0xF0000000)) { result += 4; x <<= 4; }
	while (!(x & 0x80000000)) { result += 1; x <<= 1; }
	return result;
}
#endif

fix16_t fix16_div(fix16_t a, fix16_t b)
{
	// This uses a hardware 32/32 bit division multiple times, until we have
	// computed all the bits in (a<<17)/b. Usually this takes 1-3 iterations.
	
	if (b == 0)
			return fix16_minimum;
	
	uint32_t remainder = (a >= 0) ? a : (-a);
	uint32_t divider = (b >= 0) ? b : (-b);
	uint32_t quotient = 0;
	int bit_pos = 17;
	
	// Kick-start the division a bit.
	// This improves speed in the worst-case scenarios where N and D are large
	// It gets a lower estimate for the result by N/(D >> 17 + 1).
	if (divider & 0xFFF00000)
	{
		uint32_t shifted_div = ((divider >> 17) + 1);
		quotient = remainder / shifted_div;
		remainder -= ((uint64_t)quotient * divider) >> 17;
	}
	
	// If the divider is divisible by 2^n, take advantage of it.
	while (!(divider & 0xF) && bit_pos >= 4)
	{
		divider >>= 4;
		bit_pos -= 4;
	}
	
	while (remainder && bit_pos >= 0)
	{
		// Shift remainder as much as we can without overflowing
		int shift = clz(remainder);
		if (shift > bit_pos) shift = bit_pos;
		remainder <<= shift;
		bit_pos -= shift;
		
		uint32_t div = remainder / divider;
		remainder = remainder % divider;
		quotient += div << bit_pos;

		#ifndef FIXMATH_NO_OVERFLOW
		if (div & ~(0xFFFFFFFF >> bit_pos))
				return fix16_overflow;
		#endif
		
		remainder <<= 1;
		bit_pos--;
	}
	
	#ifndef FIXMATH_NO_ROUNDING
	// Quotient is always positive so rounding is easy
	quotient++;
	#endif
	
	fix16_t result = quotient >> 1;
	
	// Figure out the sign of the result
	if ((a ^ b) & 0x80000000)
	{
		#ifndef FIXMATH_NO_OVERFLOW
		if (result == fix16_minimum)
				return fix16_overflow;
		#endif
		
		result = -result;
	}
	
	return result;
}
#endif

/* Alternative 32-bit implementation of fix16_div. Fastest on e.g. Atmel AVR.
 * This does the division manually, and is therefore good for processors that
 * do not have hardware division.
 */
#if defined(FIXMATH_OPTIMIZE_8BIT)
fix16_t fix16_div(fix16_t a, fix16_t b)
{
	// This uses the basic binary restoring division algorithm.
	// It appears to be faster to do the whole division manually than
	// trying to compose a 64-bit divide out of 32-bit divisions on
	// platforms without hardware divide.
	
	if (b == 0)
		return fix16_minimum;
	
	uint32_t remainder = (a >= 0) ? a : (-a);
	uint32_t divider = (b >= 0) ? b : (-b);

	uint32_t quotient = 0;
	uint32_t bit = 0x10000;
	
	/* The algorithm requires D >= R */
	while (divider < remainder)
	{
		divider <<= 1;
		bit <<= 1;
	}
	
	#ifndef FIXMATH_NO_OVERFLOW
	if (!bit)
		return fix16_overflow;
	#endif
	
	if (divider & 0x80000000)
	{
		// Perform one step manually to avoid overflows later.
		// We know that divider's bottom bit is 0 here.
		if (remainder >= divider)
		{
				quotient |= bit;
				remainder -= divider;
		}
		divider >>= 1;
		bit >>= 1;
	}
	
	/* Main division loop */
	while (bit && remainder)
	{
		if (remainder >= divider)
		{
				quotient |= bit;
				remainder -= divider;
		}
		
		remainder <<= 1;
		bit >>= 1;
	}	 
			
	#ifndef FIXMATH_NO_ROUNDING
	if (remainder >= divider)
	{
		quotient++;
	}
	#endif
	
	fix16_t result = quotient;
	
	/* Figure out the sign of result */
	if ((a ^ b) & 0x80000000)
	{
		#ifndef FIXMATH_NO_OVERFLOW
		if (result == fix16_minimum)
				return fix16_overflow;
		#endif
		
		result = -result;
	}
	
	return result;
}
#endif

#ifndef FIXMATH_NO_OVERFLOW
/* Wrapper around fix16_div to add saturating arithmetic. */
fix16_t fix16_sdiv(fix16_t inArg0, fix16_t inArg1)
{
	fix16_t result = fix16_div(inArg0, inArg1);
	
	if (result == fix16_overflow)
	{
		if ((inArg0 >= 0) == (inArg1 >= 0))
			return fix16_maximum;
		else
			return fix16_minimum;
	}
	
	return result;
}
#endif

fix16_t fix16_mod(fix16_t x, fix16_t y)
{
	#ifdef FIXMATH_OPTIMIZE_8BIT
		/* The reason we do this, rather than use a modulo operator
		 * is that if you don't have a hardware divider, this will result
		 * in faster operations when the angles are close to the bounds. 
		 */
		while(x >=  y) x -= y;
		while(x <= -y) x += y;
	#else
		/* Note that in C90, the sign of result of the modulo operation is
		 * undefined. in C99, it's the same as the dividend (aka numerator).
		 */
		x %= y;
	#endif

	return x;
}


#ifndef FIXMATH_NO_64BIT

fix16_t fix16_lerp8(fix16_t inArg0, fix16_t inArg1, uint8_t inFract)
{
	int64_t tempOut = int64_mul_i32_i32(inArg0, ((1 << 8) - inFract));
	tempOut = int64_add(tempOut, int64_mul_i32_i32(inArg1, inFract));
	tempOut = int64_shift(tempOut, -8);
	return (fix16_t)int64_lo(tempOut);
}

fix16_t fix16_lerp16(fix16_t inArg0, fix16_t inArg1, uint16_t inFract)
{
	int64_t tempOut = int64_mul_i32_i32(inArg0, (((int32_t)1 << 16) - inFract));
	tempOut = int64_add(tempOut, int64_mul_i32_i32(inArg1, inFract));
	tempOut = int64_shift(tempOut, -16);
	return (fix16_t)int64_lo(tempOut);
}

fix16_t fix16_lerp32(fix16_t inArg0, fix16_t inArg1, uint32_t inFract)
{
	int64_t tempOut;
	tempOut  = ((int64_t)inArg0 * (0 - inFract));
	tempOut	+= ((int64_t)inArg1 * inFract);
	tempOut >>= 32;
	return (fix16_t)tempOut;
}
#endif
#else

const float sin_table[] =
{
	0.0000000000000,
	0.0015707956808,
	0.0031415874859,
	0.0047123715394,
	0.0062831439656,
	0.0078539008887,
	0.0094246384331,
	0.0109953527232,
	0.0125660398834,
	0.0141366960380,
	0.0157073173118,
	0.0172778998294,
	0.0188484397154,
	0.0204189330948,
	0.0219893760925,
	0.0235597648336,
	0.0251300954433,
	0.0267003640471,
	0.0282705667703,
	0.0298406997387,
	0.0314107590781,
	0.0329807409147,
	0.0345506413745,
	0.0361204565840,
	0.0376901826699,
	0.0392598157591,
	0.0408293519785,
	0.0423987874556,
	0.0439681183179,
	0.0455373406932,
	0.0471064507096,
	0.0486754444956,
	0.0502443181798,
	0.0518130678911,
	0.0533816897588,
	0.0549501799124,
	0.0565185344820,
	0.0580867495977,
	0.0596548213902,
	0.0612227459903,
	0.0627905195293,
	0.0643581381390,
	0.0659255979514,
	0.0674928950989,
	0.0690600257144,
	0.0706269859312,
	0.0721937718829,
	0.0737603797036,
	0.0753268055279,
	0.0768930454909,
	0.0784590957278,
	0.0800249523748,
	0.0815906115682,
	0.0831560694448,
	0.0847213221421,
	0.0862863657979,
	0.0878511965507,
	0.0894158105395,
	0.0909802039036,
	0.0925443727831,
	0.0941083133185,
	0.0956720216511,
	0.0972354939224,
	0.0987987262748,
	0.1003617148512,
	0.1019244557951,
	0.1034869452504,
	0.1050491793620,
	0.1066111542753,
	0.1081728661361,
	0.1097343110910,
	0.1112954852875,
	0.1128563848735,
	0.1144170059975,
	0.1159773448090,
	0.1175373974578,
	0.1190971600949,
	0.1206566288715,
	0.1222157999399,
	0.1237746694529,
	0.1253332335643,
	0.1268914884284,
	0.1284494302003,
	0.1300070550360,
	0.1315643590923,
	0.1331213385266,
	0.1346779894972,
	0.1362343081632,
	0.1377902906846,
	0.1393459332222,
	0.1409012319376,
	0.1424561829932,
	0.1440107825523,
	0.1455650267791,
	0.1471189118386,
	0.1486724338969,
	0.1502255891208,
	0.1517783736779,
	0.1533307837370,
	0.1548828154676,
	0.1564344650402,
	0.1579857286264,
	0.1595366023985,
	0.1610870825299,
	0.1626371651949,
	0.1641868465689,
	0.1657361228281,
	0.1672849901500,
	0.1688334447127,
	0.1703814826958,
	0.1719291002794,
	0.1734762936451,
	0.1750230589753,
	0.1765693924535,
	0.1781152902642,
	0.1796607485932,
	0.1812057636271,
	0.1827503315539,
	0.1842944485623,
	0.1858381108426,
	0.1873813145857,
	0.1889240559841,
	0.1904663312312,
	0.1920081365215,
	0.1935494680509,
	0.1950903220161,
	0.1966306946154,
	0.1981705820480,
	0.1997099805144,
	0.2012488862163,
	0.2027872953565,
	0.2043252041393,
	0.2058626087699,
	0.2073995054550,
	0.2089358904024,
	0.2104717598213,
	0.2120071099221,
	0.2135419369163,
	0.2150762370171,
	0.2166100064387,
	0.2181432413965,
	0.2196759381077,
	0.2212080927902,
	0.2227397016639,
	0.2242707609494,
	0.2258012668691,
	0.2273312156466,
	0.2288606035070,
	0.2303894266766,
	0.2319176813832,
	0.2334453638559,
	0.2349724703254,
	0.2364989970237,
	0.2380249401843,
	0.2395502960419,
	0.2410750608330,
	0.2425992307954,
	0.2441228021683,
	0.2456457711924,
	0.2471681341100,
	0.2486898871649,
	0.2502110266021,
	0.2517315486685,
	0.2532514496123,
	0.2547707256834,
	0.2562893731330,
	0.2578073882141,
	0.2593247671810,
	0.2608415062899,
	0.2623576017983,
	0.2638730499654,
	0.2653878470519,
	0.2669019893204,
	0.2684154730347,
	0.2699282944605,
	0.2714404498651,
	0.2729519355173,
	0.2744627476878,
	0.2759728826487,
	0.2774823366740,
	0.2789911060392,
	0.2804991870216,
	0.2820065759001,
	0.2835132689555,
	0.2850192624700,
	0.2865245527278,
	0.2880291360148,
	0.2895330086185,
	0.2910361668283,
	0.2925386069353,
	0.2940403252323,
	0.2955413180141,
	0.2970415815770,
	0.2985411122194,
	0.3000399062413,
	0.3015379599445,
	0.3030352696328,
	0.3045318316116,
	0.3060276421885,
	0.3075226976726,
	0.3090169943749,
	0.3105105286086,
	0.3120032966884,
	0.3134952949311,
	0.3149865196553,
	0.3164769671816,
	0.3179666338324,
	0.3194555159322,
	0.3209436098072,
	0.3224309117858,
	0.3239174181981,
	0.3254031253765,
	0.3268880296549,
	0.3283721273697,
	0.3298554148589,
	0.3313378884626,
	0.3328195445230,
	0.3343003793843,
	0.3357803893926,
	0.3372595708962,
	0.3387379202453,
	0.3402154337923,
	0.3416921078915,
	0.3431679388994,
	0.3446429231745,
	0.3461170570775,
	0.3475903369710,
	0.3490627592200,
	0.3505343201913,
	0.3520050162540,
	0.3534748437793,
	0.3549437991405,
	0.3564118787133,
	0.3578790788751,
	0.3593453960059,
	0.3608108264876,
	0.3622753667045,
	0.3637390130430,
	0.3652017618916,
	0.3666636096411,
	0.3681245526847,
	0.3695845874175,
	0.3710437102371,
	0.3725019175432,
	0.3739592057378,
	0.3754155712253,
	0.3768710104122,
	0.3783255197073,
	0.3797790955218,
	0.3812317342691,
	0.3826834323651,
	0.3841341862277,
	0.3855839922774,
	0.3870328469369,
	0.3884807466314,
	0.3899276877882,
	0.3913736668372,
	0.3928186802106,
	0.3942627243430,
	0.3957057956712,
	0.3971478906348,
	0.3985890056754,
	0.4000291372373,
	0.4014682817670,
	0.4029064357137,
	0.4043435955287,
	0.4057797576662,
	0.4072149185824,
	0.4086490747363,
	0.4100822225893,
	0.4115143586051,
	0.4129454792502,
	0.4143755809933,
	0.4158046603059,
	0.4172327136618,
	0.4186597375374,
	0.4200857284118,
	0.4215106827664,
	0.4229345970853,
	0.4243574678551,
	0.4257792915651,
	0.4272000647069,
	0.4286197837751,
	0.4300384452666,
	0.4314560456810,
	0.4328725815204,
	0.4342880492898,
	0.4357024454966,
	0.4371157666509,
	0.4385280092656,
	0.4399391698559,
	0.4413492449401,
	0.4427582310389,
	0.4441661246758,
	0.4455729223769,
	0.4469786206711,
	0.4483832160900,
	0.4497867051679,
	0.4511890844418,
	0.4525903504515,
	0.4539904997395,
	0.4553895288511,
	0.4567874343343,
	0.4581842127399,
	0.4595798606215,
	0.4609743745355,
	0.4623677510410,
	0.4637599867001,
	0.4651510780775,
	0.4665410217408,
	0.4679298142606,
	0.4693174522100,
	0.4707039321653,
	0.4720892507055,
	0.4734734044123,
	0.4748563898706,
	0.4762382036679,
	0.4776188423949,
	0.4789983026448,
	0.4803765810140,
	0.4817536741017,
	0.4831295785102,
	0.4845042908444,
	0.4858778077125,
	0.4872501257253,
	0.4886212414970,
	0.4899911516442,
	0.4913598527871,
	0.4927273415483,
	0.4940936145538,
	0.4954586684324,
	0.4968224998160,
	0.4981851053395,
	0.4995464816407,
	0.5009066253607,
	0.5022655331434,
	0.5036232016358,
	0.5049796274880,
	0.5063348073531,
	0.5076887378875,
	0.5090414157504,
	0.5103928376042,
	0.5117430001143,
	0.5130918999496,
	0.5144395337815,
	0.5157858982850,
	0.5171309901382,
	0.5184748060220,
	0.5198173426207,
	0.5211585966218,
	0.5224985647159,
	0.5238372435968,
	0.5251746299613,
	0.5265107205096,
	0.5278455119451,
	0.5291790009742,
	0.5305111843067,
	0.5318420586557,
	0.5331716207372,
	0.5344998672707,
	0.5358267949790,
	0.5371524005879,
	0.5384766808267,
	0.5397996324277,
	0.5411212521269,
	0.5424415366631,
	0.5437604827788,
	0.5450780872195,
	0.5463943467343,
	0.5477092580753,
	0.5490228179981,
	0.5503350232618,
	0.5516458706284,
	0.5529553568638,
	0.5542634787367,
	0.5555702330196,
	0.5568756164882,
	0.5581796259215,
	0.5594822581022,
	0.5607835098159,
	0.5620833778521,
	0.5633818590035,
	0.5646789500661,
	0.5659746478395,
	0.5672689491268,
	0.5685618507343,
	0.5698533494719,
	0.5711434421531,
	0.5724321255946,
	0.5737193966167,
	0.5750052520433,
	0.5762896887015,
	0.5775727034223,
	0.5788542930398,
	0.5801344543919,
	0.5814131843198,
	0.5826904796686,
	0.5839663372865,
	0.5852407540255,
	0.5865137267412,
	0.5877852522925,
	0.5890553275421,
	0.5903239493563,
	0.5915911146048,
	0.5928568201611,
	0.5941210629020,
	0.5953838397084,
	0.5966451474642,
	0.5979049830575,
	0.5991633433797,
	0.6004202253259,
	0.6016756257949,
	0.6029295416890,
	0.6041819699145,
	0.6054329073810,
	0.6066823510020,
	0.6079302976946,
	0.6091767443796,
	0.6104216879816,
	0.6116651254287,
	0.6129070536530,
	0.6141474695900,
	0.6153863701792,
	0.6166237523637,
	0.6178596130903,
	0.6190939493098,
	0.6203267579766,
	0.6215580360487,
	0.6227877804881,
	0.6240159882606,
	0.6252426563357,
	0.6264677816867,
	0.6276913612907,
	0.6289133921287,
	0.6301338711854,
	0.6313527954494,
	0.6325701619131,
	0.6337859675729,
	0.6350002094288,
	0.6362128844848,
	0.6374239897487,
	0.6386335222323,
	0.6398414789512,
	0.6410478569248,
	0.6422526531766,
	0.6434558647338,
	0.6446574886276,
	0.6458575218931,
	0.6470559615694,
	0.6482528046995,
	0.6494480483302,
	0.6506416895124,
	0.6518337253009,
	0.6530241527545,
	0.6542129689359,
	0.6554001709118,
	0.6565857557530,
	0.6577697205340,
	0.6589520623337,
	0.6601327782347,
	0.6613118653237,
	0.6624893206913,
	0.6636651414325,
	0.6648393246458,
	0.6660118674343,
	0.6671827669046,
	0.6683520201678,
	0.6695196243388,
	0.6706855765367,
	0.6718498738846,
	0.6730125135098,
	0.6741734925434,
	0.6753328081210,
	0.6764904573820,
	0.6776464374701,
	0.6788007455329,
	0.6799533787224,
	0.6811043341945,
	0.6822536091094,
	0.6834012006313,
	0.6845471059287,
	0.6856913221741,
	0.6868338465444,
	0.6879746762204,
	0.6891138083874,
	0.6902512402344,
	0.6913869689552,
	0.6925209917474,
	0.6936533058128,
	0.6947839083577,
	0.6959127965923,
	0.6970399677313,
	0.6981654189935,
	0.6992891476019,
	0.7004111507838,
	0.7015314257709,
	0.7026499697989,
	0.7037667801079,
	0.7048818539424,
	0.7059951885509,
	0.7071067811866,
	0.7082166291065,
	0.7093247295723,
	0.7104310798498,
	0.7115356772093,
	0.7126385189252,
	0.7137396022764,
	0.7148389245461,
	0.7159364830218,
	0.7170322749954,
	0.7181262977632,
	0.7192185486257,
	0.7203090248879,
	0.7213977238592,
	0.7224846428534,
	0.7235697791885,
	0.7246531301871,
	0.7257346931761,
	0.7268144654869,
	0.7278924444553,
	0.7289686274214,
	0.7300430117299,
	0.7311155947299,
	0.7321863737748,
	0.7332553462226,
	0.7343225094357,
	0.7353878607810,
	0.7364513976299,
	0.7375131173582,
	0.7385730173461,
	0.7396310949786,
	0.7406873476449,
	0.7417417727387,
	0.7427943676585,
	0.7438451298070,
	0.7448940565916,
	0.7459411454242,
	0.7469863937211,
	0.7480297989034,
	0.7490713583965,
	0.7501110696305,
	0.7511489300400,
	0.7521849370641,
	0.7532190881467,
	0.7542513807361,
	0.7552818122852,
	0.7563103802515,
	0.7573370820971,
	0.7583619152887,
	0.7593848772977,
	0.7604059656000,
	0.7614251776762,
	0.7624425110115,
	0.7634579630956,
	0.7644715314231,
	0.7654832134931,
	0.7664930068094,
	0.7675009088803,
	0.7685069172191,
	0.7695110293434,
	0.7705132427758,
	0.7715135550433,
	0.7725119636779,
	0.7735084662159,
	0.7745030601987,
	0.7754957431722,
	0.7764865126871,
	0.7774753662986,
	0.7784623015670,
	0.7794473160571,
	0.7804304073383,
	0.7814115729852,
	0.7823908105766,
	0.7833681176965,
	0.7843434919334,
	0.7853169308808,
	0.7862884321366,
	0.7872579933040,
	0.7882256119904,
	0.7891912858086,
	0.7901550123757,
	0.7911167893139,
	0.7920766142500,
	0.7930344848158,
	0.7939903986478,
	0.7949443533875,
	0.7958963466810,
	0.7968463761794,
	0.7977944395386,
	0.7987405344193,
	0.7996846584871,
	0.8006268094125,
	0.8015669848709,
	0.8025051825424,
	0.8034414001121,
	0.8043756352701,
	0.8053078857111,
	0.8062381491350,
	0.8071664232464,
	0.8080927057549,
	0.8090169943750,
	0.8099392868260,
	0.8108595808324,
	0.8117778741233,
	0.8126941644331,
	0.8136084495008,
	0.8145207270705,
	0.8154309948913,
	0.8163392507172,
	0.8172454923071,
	0.8181497174250,
	0.8190519238398,
	0.8199521093255,
	0.8208502716608,
	0.8217464086296,
	0.8226405180209,
	0.8235325976284,
	0.8244226452512,
	0.8253106586930,
	0.8261966357628,
	0.8270805742746,
	0.8279624720472,
	0.8288423269048,
	0.8297201366763,
	0.8305958991958,
	0.8314696123026,
	0.8323412738407,
	0.8332108816594,
	0.8340784336132,
	0.8349439275613,
	0.8358073613683,
	0.8366687329037,
	0.8375280400422,
	0.8383852806634,
	0.8392404526524,
	0.8400935538990,
	0.8409445822982,
	0.8417935357502,
	0.8426404121604,
	0.8434852094392,
	0.8443279255020,
	0.8451685582696,
	0.8460071056679,
	0.8468435656276,
	0.8476779360851,
	0.8485102149815,
	0.8493404002633,
	0.8501684898821,
	0.8509944817947,
	0.8518183739630,
	0.8526401643541,
	0.8534598509404,
	0.8542774316993,
	0.8550929046136,
	0.8559062676711,
	0.8567175188651,
	0.8575266561937,
	0.8583336776605,
	0.8591385812743,
	0.8599413650490,
	0.8607420270040,
	0.8615405651635,
	0.8623369775573,
	0.8631312622204,
	0.8639234171928,
	0.8647134405202,
	0.8655013302530,
	0.8662870844474,
	0.8670707011645,
	0.8678521784708,
	0.8686315144382,
	0.8694087071436,
	0.8701837546695,
	0.8709566551035,
	0.8717274065385,
	0.8724960070728,
	0.8732624548099,
	0.8740267478588,
	0.8747888843335,
	0.8755488623536,
	0.8763066800439,
	0.8770623355346,
	0.8778158269611,
	0.8785671524644,
	0.8793163101906,
	0.8800632982911,
	0.8808081149230,
	0.8815507582484,
	0.8822912264350,
	0.8830295176556,
	0.8837656300887,
	0.8844995619180,
	0.8852313113325,
	0.8859608765267,
	0.8866882557006,
	0.8874134470593,
	0.8881364488136,
	0.8888572591794,
	0.8895758763783,
	0.8902922986372,
	0.8910065241884,
	0.8917185512695,
	0.8924283781237,
	0.8931360029997,
	0.8938414241513,
	0.8945446398380,
	0.8952456483248,
	0.8959444478820,
	0.8966410367852,
	0.8973354133159,
	0.8980275757606,
	0.8987175224116,
	0.8994052515664,
	0.9000907615281,
	0.9007740506054,
	0.9014551171123,
	0.9021339593682,
	0.9028105756983,
	0.9034849644330,
	0.9041571239084,
	0.9048270524660,
	0.9054947484528,
	0.9061602102213,
	0.9068234361296,
	0.9074844245411,
	0.9081431738251,
	0.9087996823560,
	0.9094539485141,
	0.9101059706850,
	0.9107557472599,
	0.9114032766355,
	0.9120485572141,
	0.9126915874035,
	0.9133323656172,
	0.9139708902741,
	0.9146071597986,
	0.9152411726209,
	0.9158729271766,
	0.9165024219069,
	0.9171296552586,
	0.9177546256840,
	0.9183773316411,
	0.9189977715934,
	0.9196159440101,
	0.9202318473659,
	0.9208454801410,
	0.9214568408215,
	0.9220659278988,
	0.9226727398701,
	0.9232772752382,
	0.9238795325113,
	0.9244795102035,
	0.9250772068345,
	0.9256726209294,
	0.9262657510191,
	0.9268565956401,
	0.9274451533347,
	0.9280314226505,
	0.9286154021410,
	0.9291970903654,
	0.9297764858883,
	0.9303535872801,
	0.9309283931169,
	0.9315009019805,
	0.9320711124582,
	0.9326390231431,
	0.9332046326339,
	0.9337679395350,
	0.9343289424566,
	0.9348876400144,
	0.9354440308299,
	0.9359981135302,
	0.9365498867482,
	0.9370993491225,
	0.9376464992972,
	0.9381913359225,
	0.9387338576539,
	0.9392740631528,
	0.9398119510863,
	0.9403475201273,
	0.9408807689542,
	0.9414116962514,
	0.9419403007088,
	0.9424665810221,
	0.9429905358929,
	0.9435121640282,
	0.9440314641411,
	0.9445484349501,
	0.9450630751798,
	0.9455753835603,
	0.9460853588276,
	0.9465929997232,
	0.9470983049948,
	0.9476012733954,
	0.9481019036840,
	0.9486001946255,
	0.9490961449903,
	0.9495897535547,
	0.9500810191008,
	0.9505699404164,
	0.9510565162952,
	0.9515407455365,
	0.9520226269457,
	0.9525021593337,
	0.9529793415172,
	0.9534541723190,
	0.9539266505674,
	0.9543967750966,
	0.9548645447467,
	0.9553299583633,
	0.9557930147983,
	0.9562537129091,
	0.9567120515588,
	0.9571680296167,
	0.9576216459576,
	0.9580728994623,
	0.9585217890174,
	0.9589683135152,
	0.9594124718541,
	0.9598542629380,
	0.9602936856770,
	0.9607307389867,
	0.9611654217889,
	0.9615977330109,
	0.9620276715861,
	0.9624552364537,
	0.9628804265586,
	0.9633032408518,
	0.9637236782900,
	0.9641417378359,
	0.9645574184578,
	0.9649707191302,
	0.9653816388333,
	0.9657901765531,
	0.9661963312817,
	0.9666001020169,
	0.9670014877624,
	0.9674004875279,
	0.9677971003289,
	0.9681913251867,
	0.9685831611286,
	0.9689726071879,
	0.9693596624036,
	0.9697443258207,
	0.9701265964901,
	0.9705064734685,
	0.9708839558187,
	0.9712590426093,
	0.9716317329147,
	0.9720020258154,
	0.9723699203977,
	0.9727354157539,
	0.9730985109821,
	0.9734592051865,
	0.9738174974771,
	0.9741733869699,
	0.9745268727866,
	0.9748779540551,
	0.9752266299092,
	0.9755728994886,
	0.9759167619388,
	0.9762582164113,
	0.9765972620638,
	0.9769338980597,
	0.9772681235682,
	0.9775999377648,
	0.9779293398307,
	0.9782563289532,
	0.9785809043255,
	0.9789030651466,
	0.9792228106218,
	0.9795401399620,
	0.9798550523843,
	0.9801675471116,
	0.9804776233730,
	0.9807852804032,
	0.9810905174433,
	0.9813933337401,
	0.9816937285464,
	0.9819917011210,
	0.9822872507287,
	0.9825803766402,
	0.9828710781324,
	0.9831593544878,
	0.9834452049953,
	0.9837286289495,
	0.9840096256511,
	0.9842881944068,
	0.9845643345292,
	0.9848380453370,
	0.9851093261548,
	0.9853781763132,
	0.9856445951490,
	0.9859085820047,
	0.9861701362290,
	0.9864292571765,
	0.9866859442079,
	0.9869401966898,
	0.9871920139948,
	0.9874413955017,
	0.9876883405951,
	0.9879328486658,
	0.9881749191103,
	0.9884145513314,
	0.9886517447379,
	0.9888864987445,
	0.9891188127720,
	0.9893486862471,
	0.9895761186027,
	0.9898011092775,
	0.9900236577166,
	0.9902437633706,
	0.9904614256967,
	0.9906766441576,
	0.9908894182223,
	0.9910997473660,
	0.9913076310695,
	0.9915130688200,
	0.9917160601106,
	0.9919166044403,
	0.9921147013145,
	0.9923103502442,
	0.9925035507468,
	0.9926943023456,
	0.9928826045698,
	0.9930684569549,
	0.9932518590423,
	0.9934328103795,
	0.9936113105200,
	0.9937873590234,
	0.9939609554552,
	0.9941320993872,
	0.9943007903970,
	0.9944670280685,
	0.9946308119914,
	0.9947921417617,
	0.9949510169813,
	0.9951074372581,
	0.9952614022063,
	0.9954129114459,
	0.9955619646031,
	0.9957085613101,
	0.9958527012052,
	0.9959943839327,
	0.9961336091432,
	0.9962703764929,
	0.9964046856446,
	0.9965365362667,
	0.9966659280340,
	0.9967928606272,
	0.9969173337331,
	0.9970393470446,
	0.9971589002606,
	0.9972759930862,
	0.9973906252323,
	0.9975027964163,
	0.9976125063612,
	0.9977197547965,
	0.9978245414574,
	0.9979268660855,
	0.9980267284283,
	0.9981241282393,
	0.9982190652782,
	0.9983115393108,
	0.9984015501090,
	0.9984890974505,
	0.9985741811195,
	0.9986568009060,
	0.9987369566060,
	0.9988146480219,
	0.9988898749620,
	0.9989626372406,
	0.9990329346781,
	0.9991007671012,
	0.9991661343425,
	0.9992290362407,
	0.9992894726406,
	0.9993474433930,
	0.9994029483550,
	0.9994559873895,
	0.9995065603657,
	0.9995546671589,
	0.9996003076503,
	0.9996434817272,
	0.9996841892833,
	0.9997224302180,
	0.9997582044370,
	0.9997915118520,
	0.9998223523808,
	0.9998507259474,
	0.9998766324817,
	0.9999000719198,
	0.9999210442038,
	0.9999395492821,
	0.9999555871090,
	0.9999691576448,
	0.9999802608561,
	0.9999888967156,
	0.9999950652019,
	0.9999987662997,
	1.0000000000000,
};
#define M_PI 3.141592653
float fix16_sin(float theta)
{
	int index = theta / (M_PI / 2 / 1000);
	index = index % 4000;
	if (index < 0)
		index += 4000;
	if (index > 3000)
		return -sin_table[4000 - index];
	else if (index > 2000)
		return -sin_table[index - 2000];
	else if (index > 1000)
		return sin_table[2000 - index];
	else
		return sin_table[index];
}
float fix16_cos(float theta)
{
	return fix16_sin(M_PI / 2 - theta);
}
#endif